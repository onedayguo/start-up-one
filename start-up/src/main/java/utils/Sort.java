package utils;import java.util.Arrays;/** * 10大排序算法 * 稳定的排序算法：冒泡排序O(n2)、插入排序O(n2)、归并排序O(n log n)和基数排序O(nk)。 * 不是稳定的排序算法：选择排序O(n2)、快速排序O(n log n)、希尔排序O(n log n)、堆排序O(n log n)。 */public class Sort {    //region 1.冒泡排序方法，传入一个数组,O(n2)    //    冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，    //    如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。    //    这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。    //    作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。    //    1. 算法步骤    //    比较相邻的元素。如果第一个比第二个大，就交换他们两个。    //    对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。    //    针对所有的元素重复以上的步骤，除了最后一个。    //    持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。    public static int[] BubbleSort(int[] sourceArray)    {        //对arr进行拷贝，不改变参数内容        int[] arr = Arrays.copyOf(sourceArray,sourceArray.length);        //i控制循环的次数，只需要排序N-1个数字，从1开始，也方便j的循环        for (int i = 1 ,length = arr.length; i < length ; i++) {            //设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成            boolean flag = true;            for (int j = 0,temp; j < length-i; j++) {                if (arr[j] > arr[j+1]) {    //前后数字交换                    temp = arr[j];                    arr[j] = arr[j+1];                    arr[j+1] = temp;                    flag = false;                }            }            if (flag) break;        }        return arr;    }    //endregion    //region 2.选择排序，O(n²) ，首先在未排序序列中找到最小元素，存放到排序序列的起始位置    //    唯一的好处可能就是不占用额外的内存空间了吧。    //     1. 算法步骤    //    首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置    //    再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。    //    重复第二步，直到所有元素均排序完毕。public int[] slectSort(int[] sourceArray) {    int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);//复制一份    // 总共要经过 N-1 轮比较，最后一位不用比较，是最大的数    for (int i = 0; i < arr.length - 1; i++) {        int min = i;        // 每轮需要比较的次数 N-i，找到未排序中的最小值        for (int j = i + 1; j < arr.length; j++) {            if (arr[j] < arr[min]) {                // 记录目前能找到的最小值元素的下标                min = j;            }        }        // 将找到的最小值和i位置所在的值进行交换        if (i != min) {            int tmp = arr[i];            arr[i] = arr[min];            arr[min] = tmp;        }    }    return arr;}    //endregion    //region 3.插入排序O(n2)，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。扑克牌    // 和冒泡排序一样，也有一种优化算法，叫做拆半插入。    //    因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，    //    1. 算法步骤    //    将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。    //    从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）public int[] insertSort(int[] sourceArray){    // 对 arr 进行拷贝，不改变参数内容    int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);    // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的    for (int i = 1; i < arr.length; i++) {        // 记录要插入的数据        int tmp = arr[i];        // 从已经排序的序列最右边的开始比较，找到比其小的数        int j = i;        while (j > 0 && tmp < arr[j - 1]) {            arr[j] = arr[j - 1];            j--;        }        // 存在比其小的数，插入        if (j != i) {            arr[j] = tmp;        }    }    return arr;}    //endregion    //region 4.希尔排序，非稳定，O(n log n)，改进版插入排序，增量step子序列进行插入排序，step = 10,5,2,1    // 也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。    /**     * 子序列的构成不是简单第“逐段分割”     * 将像个某个增量dk的记录组成一个子序列     * 让增量dk逐趟缩短，如（5,3,1），知道dk=1为止     * 优点：小元素跳跃式前移，大元素跳跃式后移     * 最后一趟增量为1时，序列已基本有序，平均性能优于直接插入排序     * @param sourceArray     * @return     */    public static int[] shellSort(int[] sourceArray) {        int arrLength = sourceArray.length;        //增量每次都/2,越来越小，直到为1        for (int step = arrLength / 2; step > 0; step /= 2) {            //从增量那组开始进行插入排序，直至完毕，组内第二个元素开始插入排序            for (int i = step; i < arrLength; i++) {                int j = i;                int temp = sourceArray[j];                // 组内进行插入排序，j - step 就是代表与它同组的前一个元素；后元素大于前元素并且前元素下标 > 0 ，则元素后移                while (j - step >= 0 && sourceArray[j - step] > temp) {                    sourceArray[j] = sourceArray[j - step];                    j = j - step;//定义J变量的意义，在组内插入排序控制变量                }                sourceArray[j] = temp;//一组插入排序最后步骤：元素后移完成后，将待插入元素放到指定位置            }        }    return sourceArray;    }    //endregion    //region 5.归并排序，递归拆分 合并，时间 O(nlgn)，空间O(n)，二路归并，递归分解为2个子序列，递归合并    /**     * 分而治之(divide - conquer);每个递归过程涉及三个步骤     * 第一, 分解: 把待排序的 n 个元素的序列分解成两个子序列, 每个子序列包括 n/2 个元素.     * 第二, 治理: 对每个子序列分别调用归并排序MergeSort, 进行递归操作     * 第三, 合并: 合并两个排好序的子序列,生成排序结果.     */    public static int[] sort(int[] a,int low,int high){        if (a ==null || a.length == 1) return a; //判断数组是否为空，如果为空则直接返回        int mid = (low+high)/2;        if(low<high){            sort(a,low,mid);//左递归，最终返回排好序的数组            sort(a,mid+1,high);//右递归            //左右归并            merge(a,low,mid,high);        }        return a;    }    public static void merge(int[] a, int low, int mid, int high) {        int[] temp = new int[high-low+1];//创建一个相同大小的数组        int i= low;//左数组下标        int j = mid+1;//右数组下标        int k = 0;//临时数组下标        // 把较小的数先移到新数组中，当左右数组都没有完全遍历的条件下，左右数组中肯定有一个数组先遍历完        while(i<=mid && j<=high){            if(a[i]<a[j]){           //对左右两个数组的元素依次进行比较，将小的数先放入临时数组中                temp[k++] = a[i++];            }else{                temp[k++] = a[j++];            }        }        // 把左边剩余的数移入数组        while(i<=mid){            temp[k++] = a[i++];        }        // 把右边边剩余的数移入数组        while(j<=high){            temp[k++] = a[j++];        }        // 把新数组中的数覆盖nums数组        for(int x=0;x<temp.length;x++){            a[x+low] = temp[x];        }    }    //endregion    //region 6.快速排序，不稳定，O（N log N），选取基准值，左右归类，递归调用    /*     * 快速排序     * 参数说明：     *     a -- 待排序的数组     *     l -- 数组的左边界(例如，从起始位置开始排序，则l=0)     *     r -- 数组的右边界(例如，排序截至到数组末尾，则r=a.length-1)     */    public static void quick_sort(int[] array, int start, int end)    {        if (start < end)        {            int i,j,key;            i = start;//左指针            j = end;//右指针            key = array[i];//以分组第一个数为基准值            while (i < j) //左指针 小于 右指针            {                //右值与基准值比较 ， 左值与基准值比较                while(i < j && array[j] > key)// 右值大于基准值，指针左移                    j--;                if(i < j)       //判断左指针小于右指针                    array[i++] = array[j];//右值与基准值交换                while(i < j && array[i] < key)                    i++; // 从左向右找第一个大于x的数                if(i < j)                    array[j--] = array[i];//左值与基准值交换            }            array[i] = key;//左右指针相遇，将key值填充到相遇点            quick_sort(array, start, i-1); //左递归调用，从0 到相遇点前一位            quick_sort(array, i+1, end); //右递归，从相遇点后一位 到 最后        }    }    //endregion}